# 计算机组成原理

## 第2章 运算方法和运算器

### 表示法

整数：

- 原码
- 反码
- 补码
- 移码 移码=反码的标识位取反

浮点数：

- $N=M*R^E$ 
- M为尾数，E为指数，R为基数（一般为2）

<img src="./img/截屏2023-11-08 21.11.49.png" alt="截屏2023-11-08 21.11.49" style="zoom:33%;" />

- 浮点数的 ***规格化表示*** ：M≠0时
  - 若尾数用原码表示。规定1/2≤|M|<1，即M=0.1xxx or 1.1xxx
  - 若尾数用补码表示。规定1/2≤|M|<1 or -1≤M<-1/2，即M=0.1xxx or 1.0xxx

<img src="./img/截屏2023-11-08 21.19.03.png" alt="截屏2023-11-08 21.19.03" style="zoom: 33%;" />

- IEEE 754标准

<img src="./img/截屏2023-11-08 21.19.59.png" alt="截屏2023-11-08 21.19.59" style="zoom:33%;" />

- 32位浮点数中
  - E的计算方法为真值加上固定偏移值127，即E=[1,254]（255是无穷大，0是机器零）对应真值[-126,127]
  - M是尾数，原码表示小数部分，整数部分隐藏1
  - $X=(-1)^S*(1.M)*2^{E-127}$ 
- 64位浮点数中
  - E加偏移值1023，E取值[1,2046]，真值[-1022,1023]
  - $X=(-1)^S*(1.M)*2^{E-1023}$ 

<img src="./img/截屏2023-11-08 21.26.06.png" alt="截屏2023-11-08 21.26.06" style="zoom:33%;" />

### ASCII

- 011 0000 = '0'
- 100 0001 = 'A'
- 110 0001 = 'a'

### 端序

大端序：高字节存低地址，0x1234存为 0x12 0x34

小端序：相反，0x1234存为 0x34 0x12



### 定点加减

记得减法用补码操作就行

#### 溢出检测

1.单符号位 $V=C_f\oplus C_0 其中C_f为符号为进位，C_0为最高有效位进位$ 

2.双符号位 

- 01 上溢
- 10 下溢

### 加法器

#### 门延迟时间

<img src="./img/截屏2023-11-08 21.41.30.png" alt="截屏2023-11-08 21.41.30" style="zoom:33%;" /><img src="./img/截屏2023-11-08 21.44.33.png" alt="截屏2023-11-08 21.44.33" style="zoom:33%;" />



### 乘法器

阵列乘法器实现$n*n$乘法时要$n*(n-1)个全加器和n^2个与门,所需时间为t_m=(8n-6)T$

直接补码阵列乘法器：

- 乘数都变成补码
- 如果最高符号位为负权，用括号括起来，参与运算，具有负权的进位实际上是借位

<img src="./img/截屏2023-11-08 21.54.56.png" alt="截屏2023-11-08 21.54.56" style="zoom:33%;" />

### 定点除法运算

#### 原码除法

每次对比能不能商1

#### 恢复余数法

- 用双符号位
- $x-y变成x+[-y]_补$,余数$r_0<0商0，则加y恢复余数，r_0>0则商1，下一步依然是+[y]_补]$ 

#### 加减交替法

- 当余数小于0时商0，不恢复余数，而是余数左移一位再加上除数，
- 余数大于0时商1，余数左移一位减去除数得到新的余数
- 计算过程中如果余数为负数需要回到上一个正数
- 除数为负时余数要变号

### 浮点运算

阶码小的尾数向阶码大的对齐，然后尾数进行运算，然后乘阶码

#### 结果规格化

00.1xxx和11.0xxx为规格化数

00.0xxx和11.1xxx需要尾数左移实现规格化

01.xxx和10.xxx为溢出情况，需要右规



## 第3章 存储系统

### 静态随机读写存储器SRAM

用一个 ***触发器*** 作为 ***存储元*** ，在不断电时可以无限期保留记忆的0/1

- 数据线：决定储存单元的字长
- 控制线：决定读/写操作
- 地址线：译码后产生字选择线（行线）

译码器使能端：

<img src="./img/截屏2023-11-08 22.25.52.png" alt="截屏2023-11-08 22.25.52" style="zoom:33%;" /><img src="./img/截屏2023-11-08 22.26.10.png" alt="截屏2023-11-08 22.26.10"  />

#### 读写周期

<img src="./img/截屏2023-11-08 22.34.07.png" alt="截屏2023-11-08 22.34.07" style="zoom: 25%;" /><img src="./img/截屏2023-11-08 22.34.32.png" alt="截屏2023-11-08 22.34.32" style="zoom: 25%;" />

### 动态随机存储器DRAM

储存元：由一个MOS管和电容组成的记忆电路，1和0有电容器上电荷量体现

<img src="./img/截屏2023-11-08 22.38.29.png" alt="截屏2023-11-08 22.38.29" style="zoom: 25%;" />

<img src="./img/截屏2023-11-08 22.39.12.png" alt="截屏2023-11-08 22.39.12" style="zoom: 33%;" />

#### 画图给分细则

<img src="./img/截屏2023-11-08 22.43.42.png" alt="截屏2023-11-08 22.43.42" style="zoom: 25%;" />

### Cache

#### 命中率

$h=\frac{N_c}{N_c+N_m}$                $N_c为Cache完成存取的总次数，N_m表示主存完成存取的总次数$

$若t_c表示命中时的Cache访问时间，t_m表示未命中时的主存访问时间，则Catch/主存系统平均访问时间为$

$t_a=ht_c+(1-h)t_m$

$r=\frac{t_m}{t_c}表示主存慢于Cache的倍率$

$访问效率e=\frac{t_c}{t_a}=\frac{1}{1+(1-h)(r-1)}$

#### 地址映射

##### 全映射方式

<img src="./img/截屏2023-11-08 22.52.50.png" alt="截屏2023-11-08 22.52.50" style="zoom:33%;" />

##### 直接映射方式

<img src="./img/截屏2023-11-08 22.53.31.png" alt="截屏2023-11-08 22.53.31" style="zoom:33%;" />



##### 组相联映射方式

<img src="./img/截屏2023-11-08 22.53.48.png" alt="截屏2023-11-08 22.53.48" style="zoom:33%;" />



## 第4章 指令系统

指令系统的性能要求

- 完备性
- 有效性
- 规整性
- 兼容性



### 指令格式：	操作码字段OP + 地址码字段A

- 零地址指令  eg.关机指令

- 一地址指令  另一个操作数地址是隐含的

- 二地址指令
  - SS型
  - RR型
  - RS型

- 三地址指令

  

定长编码：操作码长度为k则最多只能有$2^k$条指令

变长编码：可以增加指令种类，方法：操作码扩展到地址字段



### 寻址

指令寻址：

- 顺序寻址：一条条执行，使用程序计数器PC来计数指令的顺序号，顺序好就是指令在主存的地址
- 跳跃寻址：下一跳指令由本条指令给出，跳跃后按新的指令地址开始顺序执行



操作数寻址：

操作数地址码不会很长，但主存容量越来越大，因此仅能访问主村的一部分

指令中地址码字段给出的地址位 ***形式地址*** D ，如果该地址能直接访问主存，则称为 ***有效地址*** E

寻址就是把操作数的形式地址变换为有效地址

- 隐含寻址：指令中不明显给出操作数地址 eg单地址的指令格式，隐藏累加寄存器AC作为第二操作数地址
- 立即寻址： OP（移位）| F | D  
  - D是一个操作数，F是标识位，0/1决定左/右移
  - 取指同时取出操作码和操作数，不需要访问存储器
- 直接寻址： OP | X | D
  - 此时，形式地址D就是有效地址E，E=D，操作数S=（E）=（D）
- 间接寻址：形式地址是操作数地址的地址
  - E=（D），S=（E）=((D))
- 寄存器寻址：地址码部分给出一个通用寄存器编号，D=寄存器R，寄存器中的内容是操作数
- 寄存器间接寻址：寄存器中的内容是操作数的有效地址
- 相对寻址：把程序计数器PC中的内容加上指令中的形式地址D
- 变址寻址：变址寄存器中的内容+形式地址D=有效地址E       <font color=Red>这里的D为基地址</font>
- 基址寻址：基址寄存器中的内容+形式地址D=有效地址E.   <font color=Red>这里的D为偏移地址</font>
- 块寻址：通常在指令中指出数据块的起始地址和数据块的长度
- 段寻址：扩大寻址范围而采用的方法，8086中采用
- 堆栈寻址：特定存储区，后进先出

### 解题

问指令格式和寻址方式的特点：

- 几地址指令
- 操作码几位
- 指令格式是？ RR/RS/SS
- 指令的寻址方式是什么 



分析执行时间：

- 看访问几次寄存器，几次内存。寄存器快于内存



看指令字是否正确：

- 看有没有对应操作码
- 看长度是否对应该操作码该有的指令长度



